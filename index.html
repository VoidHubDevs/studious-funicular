<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Meme Sound Battle — Full Recorder</title>
<style>
:root{
  --bg1:#021028; --card:#0c1630; --muted:#9fb0d9; --accent:#6f8cff; --accent2:#7ce3c9;
  font-family:Inter,system-ui,-apple-system,Segoe UI,Roboto,"Helvetica Neue",Arial;
}
*{box-sizing:border-box}
html,body{height:100%;margin:0;background:linear-gradient(180deg,var(--bg1),#041a33);color:#eaf2ff;overflow:hidden}
.app{display:grid;grid-template-columns:320px 1fr 300px;gap:14px;height:100vh;padding:18px;position:relative;z-index:2}
.panel{background:linear-gradient(180deg, rgba(255,255,255,0.02), transparent);border:1px solid rgba(255,255,255,0.03);border-radius:12px;padding:12px;overflow:auto}
h2{margin:0 0 8px 0;color:var(--accent)}
.hint{color:var(--muted);font-size:13px;margin-bottom:8px}
.row{display:flex;gap:8px;align-items:center}
.btn{background:rgba(255,255,255,0.03);border:1px solid rgba(255,255,255,0.03);padding:8px 10px;border-radius:8px;color:var(--muted);cursor:pointer}
.btn.primary{background:linear-gradient(90deg,var(--accent),var(--accent2));color:#04243a;font-weight:700}
.small{padding:6px 8px;font-size:13px;border-radius:6px}
.fileDrop{display:block;padding:10px;border-radius:8px;border:1px dashed rgba(255,255,255,0.04);text-align:center;color:var(--muted);cursor:pointer}
.sound-list{display:flex;flex-direction:column;gap:8px;margin-top:8px}
.sound-item{display:flex;gap:8px;align-items:center;padding:8px;border-radius:10px;background:rgba(255,255,255,0.02);border:1px solid rgba(255,255,255,0.02)}
.cover{width:56px;height:56px;border-radius:10px;background:#081020;flex:0 0 56px;display:flex;align-items:center;justify-content:center;color:var(--muted)}
.sound-meta input[type="text"]{width:100%;border:none;background:transparent;color:inherit;font-weight:700;font-size:14px}
.controls{display:flex;gap:8px;align-items:center;margin-top:10px;flex-wrap:wrap}
.arenaWrap{position:relative;display:flex;flex-direction:column;gap:10px;align-items:stretch;justify-content:center}
.arena{flex:1;border-radius:18px;position:relative;overflow:hidden;border:2px solid rgba(255,255,255,0.03);background:transparent;display:flex;align-items:center;justify-content:center}
.canvasStack{position:relative;width:92%;height:86%;border-radius:14px;overflow:hidden;box-shadow:0 12px 40px rgba(3,11,40,0.6)}
#bgCanvas, #funnelCanvas, #uiCanvas{position:absolute;left:0;top:0;width:100%;height:100%;display:block}
.controlsRow{display:flex;gap:8px;align-items:center;justify-content:space-between}
.avatarLabel{font-size:12px;color:#fff;padding:6px 8px;border-radius:8px;background:rgba(0,0,0,0.55)}
.leaderboardList{display:flex;flex-direction:column;gap:8px;margin-top:8px}
.leaderRow{display:flex;gap:8px;align-items:center;padding:8px;border-radius:8px;background:rgba(255,255,255,0.02);border:1px solid rgba(255,255,255,0.02)}
.pos{width:28px;text-align:center;font-weight:800}
.lbCover{width:46px;height:46px;border-radius:8px;overflow:hidden;flex:0 0 46px}
@media (max-width:1000px){.app{grid-template-columns:1fr;grid-template-rows:260px 1fr 320px;padding:10px}}
</style>
</head>
<body>
<!-- animated background canvas (full-screen) -->
<canvas id="bgFull" style="position:fixed;left:0;top:0;right:0;bottom:0;z-index:0;pointer-events:none"></canvas>

<div class="app" style="position:relative;z-index:2">
  <!-- LEFT: manager -->
  <div class="panel" id="leftPanel">
    <h2>Sound Studio</h2>
    <div class="hint">Upload up to <strong>8</strong> sounds (audio + optional cover). Preview backgrounds & voices — choose before recording.</div>

    <label class="fileDrop" id="dropZone">Click or drop audio files here<input id="audioFiles" type="file" accept="audio/*" multiple style="display:none"></label>
    <div style="height:8px"></div>
    <div class="row">
      <label style="flex:1">Cover image <input id="coverInput" type="file" accept="image/*" style="display:none"></label>
      <button id="applyCoverBtn" class="btn small">Apply to next</button>
    </div>

    <div class="controls" style="margin-top:12px">
      <button id="addBuiltIn" class="btn small">Add demo memes</button>
      <button id="clearAll" class="btn small">Clear</button>
      <button id="startBtn" class="btn primary">Start Battle</button>
    </div>

    <div class="hint" style="margin-top:10px">Items</div>
    <div id="soundContainer" class="sound-list" aria-live="polite"></div>

    <hr style="opacity:0.05;margin:12px 0">

    <h3>Backgrounds (preview all)</h3>
    <div class="row" id="bgPresetButtons" style="flex-wrap:wrap;gap:8px;margin-top:6px"></div>

    <h3 style="margin-top:10px">Voice preview</h3>
    <div class="hint">Preview native voices (not always recordable) and a recordable robotic voice. Preview all voices before choosing.</div>
    <div style="display:flex;gap:8px;align-items:center;margin-top:6px">
      <select id="voiceSelect" style="flex:1"></select>
      <button id="previewVoice" class="btn small">Speak</button>
    </div>
    <div style="display:flex;gap:8px;align-items:center;margin-top:8px">
      <label class="row"><input id="useRobotic" type="checkbox"> Robotic voice (recordable)</label>
      <button id="previewRobot" class="btn small">Preview Robot</button>
    </div>

    <hr style="opacity:0.05;margin:12px 0">
    <h3>Intro text</h3>
    <div class="hint">Auto-generates "A vs B vs C" or use custom text. Robot voice is recordable; native voices may not always be captured.</div>
    <label><input id="autoIntro" type="checkbox" checked> Auto intro</label>
    <textarea id="introText" rows="2" style="width:100%;margin-top:6px;border-radius:8px;background:transparent;border:1px solid rgba(255,255,255,0.04);padding:8px">My sounds battle!</textarea>

    <div style="height:8px"></div>
    <h3>Recording</h3>
    <div class="row">
      <label>Format</label>
      <select id="recordFormat"><option value="video/webm">WebM</option><option value="video/mp4">MP4 (may be unavailable in some browsers)</option></select>
    </div>

    <div style="margin-top:8px;display:flex;gap:8px">
      <button id="startRecord" class="btn small">Start Recording</button>
      <button id="stopRecord" class="btn small">Stop</button>
      <button id="downloadRecord" class="btn small">Download</button>
    </div>

    <div style="height:8px"></div>
    <div class="hint">Notes: Native SpeechSynthesis works for preview; to guarantee the intro voice is included in the recorded video, enable "Robotic voice (recordable)". The recorder captures the canvas visuals + all audio routed to the page audio graph.</div>
  </div>

  <!-- CENTER: arena -->
  <div class="panel arenaWrap">
    <div class="arena">
      <div class="canvasStack" id="canvasStack">
        <canvas id="bgCanvas"></canvas>
        <canvas id="funnelCanvas"></canvas>
        <canvas id="uiCanvas"></canvas>
      </div>
    </div>

    <div class="controlsRow">
      <div class="row">
        <button id="previewDrop" class="btn small">Preview Drop</button>
        <button id="resetArena" class="btn small">Reset</button>
        <div class="avatarLabel" id="statusLabel">Ready</div>
      </div>
      <div class="row">
        <label class="hint">Up to 8</label>
      </div>
    </div>
  </div>

  <!-- RIGHT: leaderboard -->
  <div class="panel">
    <h2>Leaderboard</h2>
    <div id="leaderboard" class="leaderboardList"></div>
    <hr style="opacity:0.05;margin:12px 0">
    <h3>Winner</h3>
    <div id="winnerBox" style="min-height:140px;display:flex;align-items:center;justify-content:center;color:var(--muted)">No winner</div>
    <div style="display:flex;gap:8px;align-items:center;margin-top:8px">
      <button id="announceWinner" class="btn small">Announce Winner (TTS)</button>
      <button id="copyBoard" class="btn small">Copy leaderboard</button>
    </div>
  </div>
</div>

<script>
/* Full single-file app logic */

/* ---------- Canvas setup ---------- */
const bgFull = document.getElementById('bgFull');
const bgCanvas = document.getElementById('bgCanvas');
const funnelCanvas = document.getElementById('funnelCanvas');
const uiCanvas = document.getElementById('uiCanvas');
const stack = document.getElementById('canvasStack');

function fitCanvases(){
  const rect = stack.getBoundingClientRect();
  [bgCanvas,funnelCanvas,uiCanvas].forEach(c => {
    c.width = rect.width * devicePixelRatio;
    c.height = rect.height * devicePixelRatio;
    c.style.width = rect.width + 'px';
    c.style.height = rect.height + 'px';
  });
}
window.addEventListener('resize', ()=> {
  fitCanvases(); resizeBgFull();
});

fitCanvases();

/* ---------- Background animated full-screen ---------- */
const ctxFull = bgFull.getContext('2d');
let W = innerWidth, H = innerHeight;
bgFull.width = W * devicePixelRatio; bgFull.height = H * devicePixelRatio;
bgFull.style.width = W + 'px'; bgFull.style.height = H + 'px';
ctxFull.scale(devicePixelRatio, devicePixelRatio);

function resizeBgFull(){
  W = innerWidth; H = innerHeight;
  bgFull.width = W * devicePixelRatio; bgFull.height = H * devicePixelRatio;
  bgFull.style.width = W + 'px'; bgFull.style.height = H + 'px';
  ctxFull.setTransform(devicePixelRatio,0,0,devicePixelRatio,0,0);
}
resizeBgFull();

let bgParticles = [];
function initBGParticles(){
  bgParticles = [];
  for (let i=0;i<22;i++){
    bgParticles.push({
      x: Math.random()*W, y: Math.random()*H,
      r: 40 + Math.random()*160, vx:(Math.random()-0.5)*0.4, vy:(Math.random()-0.5)*0.4,
      hue:200 + Math.random()*80, a:0.05 + Math.random()*0.08
    });
  }
}
initBGParticles();

function drawBG(){
  // gradient background
  const g = ctxFull.createLinearGradient(0,0,W,H);
  g.addColorStop(0,'#001020'); g.addColorStop(1,'#05233b');
  ctxFull.fillStyle = g;
  ctxFull.fillRect(0,0,W,H);
  // blobs
  bgParticles.forEach(p=>{
    p.x += p.vx; p.y += p.vy;
    if (p.x < -p.r) p.x = W + p.r;
    if (p.x > W + p.r) p.x = -p.r;
    if (p.y < -p.r) p.y = H + p.r;
    if (p.y > H + p.r) p.y = -p.r;
    const rg = ctxFull.createRadialGradient(p.x,p.y,p.r*0.1,p.x,p.y,p.r);
    rg.addColorStop(0,`hsla(${p.hue},80%,70%,${p.a})`);
    rg.addColorStop(1,`hsla(${p.hue},60%,30%,0)`);
    ctxFull.fillStyle = rg; ctxFull.beginPath(); ctxFull.arc(p.x,p.y,p.r,0,Math.PI*2); ctxFull.fill();
  });
  requestAnimationFrame(drawBG);
}
drawBG();

/* ---------- Funnel canvas (render funnel + avatars) ---------- */
const fctx = funnelCanvas.getContext('2d');
const uctx = uiCanvas.getContext('2d');
fctx.scale(devicePixelRatio, devicePixelRatio);
uctx.scale(devicePixelRatio, devicePixelRatio);

function drawFunnelBase(){
  const r = stack.getBoundingClientRect();
  // clear
  fctx.clearRect(0,0,r.width,r.height);
  // draw funnel shape (rounded polygon)
  const w = r.width, h = r.height;
  fctx.save();
  // background gradient
  const grad = fctx.createLinearGradient(0,0,0,h);
  grad.addColorStop(0,'#7bb8ff'); grad.addColorStop(1,'#3ea0ff');
  fctx.fillStyle = grad;
  // polygon points
  const p1 = {x:w*0.2,y:0}, p2={x:w*0.8,y:0}, p3={x:w*0.95,y:h*0.78}, p4={x:w*0.5,y:h}, p5={x:w*0.05,y:h*0.78};
  fctx.beginPath();
  fctx.moveTo(p1.x,p1.y);
  fctx.lineTo(p2.x,p2.y);
  fctx.lineTo(p3.x,p3.y);
  fctx.lineTo(p4.x,p4.y);
  fctx.lineTo(p5.x,p5.y);
  fctx.closePath();
  fctx.fill();
  // subtle inner shadow
  fctx.globalCompositeOperation = 'multiply';
  fctx.fillStyle = 'rgba(0,0,0,0.06)';
  fctx.fill();
  fctx.globalCompositeOperation = 'source-over';
  fctx.restore();
}
drawFunnelBase();

/* ---------- Items & avatars ---------- */
const MAX_ITEMS = 8;
let items = []; // {id,name,audioUrl,coverUrl,audioEl}
let avatarState = []; // states for animation
let leaderboard = [];
let recordingChunks = [];
let recorder = null;
let mediaStream = null;
let masterDestination = null;
let audioCtx = null;
let masterGain = null;
let recordingFormat = 'video/webm';
let roboticVoiceEnabled = false;

const dropZone = document.getElementById('dropZone');
const audioFilesInput = document.getElementById('audioFiles');
const applyCoverBtn = document.getElementById('applyCoverBtn');
const coverInput = document.getElementById('coverInput');
const soundContainer = document.getElementById('soundContainer');
const addBuiltIn = document.getElementById('addBuiltIn');
const clearAll = document.getElementById('clearAll');
const startBtn = document.getElementById('startBtn');
const previewDrop = document.getElementById('previewDrop');
const resetArena = document.getElementById('resetArena');
const statusLabel = document.getElementById('statusLabel');
const leaderboardEl = document.getElementById('leaderboard');
const winnerBox = document.getElementById('winnerBox');
const announceWinner = document.getElementById('announceWinner');
const copyBoard = document.getElementById('copyBoard');
const startRecordBtn = document.getElementById('startRecord');
const stopRecordBtn = document.getElementById('stopRecord');
const downloadRecordBtn = document.getElementById('downloadRecord');
const recordFormatSelect = document.getElementById('recordFormat');
const voiceSelect = document.getElementById('voiceSelect');
const previewVoiceBtn = document.getElementById('previewVoice');
const previewRobotBtn = document.getElementById('previewRobot');
const useRoboticCheckbox = document.getElementById('useRobotic');
const introTextArea = document.getElementById('introText');
const autoIntroCheckbox = document.getElementById('autoIntro');
const bgPresetButtons = document.getElementById('bgPresetButtons');

/* handle files & cover application */
let nextCoverUrl = null;
applyCoverBtn.addEventListener('click', ()=> {
  const f = coverInput.files[0];
  if (!f){ alert('Pick a cover file first'); return; }
  nextCoverUrl = URL.createObjectURL(f);
  applyCoverBtn.textContent = 'Cover ready ✔';
});
dropZone.addEventListener('click', ()=> audioFilesInput.click());
dropZone.addEventListener('dragover', e=> { e.preventDefault(); dropZone.style.borderColor='#7bb8ff'; });
dropZone.addEventListener('dragleave', ()=> dropZone.style.borderColor='');
dropZone.addEventListener('drop', e=> {
  e.preventDefault();
  dropZone.style.borderColor='';
  const files = Array.from(e.dataTransfer.files).filter(f => f.type.startsWith('audio/'));
  handleUploaded(files);
});
audioFilesInput.addEventListener('change', e=> {
  const files = Array.from(e.target.files).filter(f => f.type.startsWith('audio/'));
  handleUploaded(files);
});

function handleUploaded(files){
  for (let f of files){
    if (items.length >= MAX_ITEMS) break;
    const aUrl = URL.createObjectURL(f);
    const cover = nextCoverUrl || null;
    addItem(f.name.replace(/\.[^/.]+$/,''), aUrl, cover);
    nextCoverUrl = null; applyCoverBtn.textContent = 'Apply to next';
  }
}

/* add item function */
function addItem(name,aUrl,cover){
  if (items.length >= MAX_ITEMS) return;
  const id = 'it'+Date.now()+Math.floor(Math.random()*999);
  const audioEl = new Audio(aUrl); audioEl.preload='auto';
  items.push({id,name,audioUrl:aUrl,coverUrl:cover,audioEl});
  renderItems();
}

/* built-in demo set (CDN links may be used) */
const builtIn = [
  {name:'Vine Boom', audio:'https://cdn.jsdelivr.net/gh/jshang/myinstants-scrape@master/sounds/vine-boom.mp3'},
  {name:'Bruh', audio:'https://cdn.jsdelivr.net/gh/jshang/myinstants-scrape@master/sounds/bruh.mp3'},
  {name:'Goofy Ahh', audio:'https://cdn.jsdelivr.net/gh/jshang/myinstants-scrape@master/sounds/goofy-ahh.mp3'},
  {name:'Discord Ping', audio:'https://cdn.jsdelivr.net/gh/jshang/myinstants-scrape@master/sounds/discord-notification.mp3'},
];
addBuiltIn.addEventListener('click', ()=> {
  builtIn.forEach(b => { if (items.length < MAX_ITEMS) addItem(b.name,b.audio,null); });
});

/* render item list UI */
function renderItems(){
  soundContainer.innerHTML = '';
  items.forEach((it,idx)=>{
    const el = document.createElement('div'); el.className='sound-item';
    const cov = document.createElement('div'); cov.className='cover';
    if (it.coverUrl){ const img = document.createElement('img'); img.src = it.coverUrl; img.style.width='100%'; img.style.height='100%'; img.style.objectFit='cover'; cov.appendChild(img); }
    else cov.textContent = (idx+1);
    el.appendChild(cov);
    const meta = document.createElement('div'); meta.style.flex='1';
    const nameIn = document.createElement('input'); nameIn.type='text'; nameIn.value = it.name;
    nameIn.addEventListener('input', ()=> { it.name = nameIn.value; updateIntro(); });
    meta.appendChild(nameIn);
    const controls = document.createElement('div'); controls.style.marginTop='6px';
    const play = document.createElement('button'); play.className='btn small'; play.textContent='Play';
    play.onclick = (e)=> { e.stopPropagation(); try{ it.audioEl.currentTime=0; it.audioEl.play(); }catch(e){} };
    const up = document.createElement('button'); up.className='btn small'; up.textContent='↑'; up.onclick=(e)=>{ e.stopPropagation(); if (idx>0){ items.splice(idx,1); items.splice(idx-1,0,it); renderItems(); } };
    const down = document.createElement('button'); down.className='btn small'; down.textContent='↓'; down.onclick=(e)=>{ e.stopPropagation(); if (idx < items.length-1){ items.splice(idx,1); items.splice(idx+1,0,it); renderItems(); } };
    const rem = document.createElement('button'); rem.className='btn small'; rem.textContent='Remove'; rem.onclick=(e)=>{ e.stopPropagation(); items.splice(idx,1); renderItems(); };
    controls.appendChild(play); controls.appendChild(up); controls.appendChild(down); controls.appendChild(rem);
    meta.appendChild(controls);
    el.appendChild(meta);
    soundContainer.appendChild(el);
  });
  updateIntro();
}

/* ---------- Intro text / voices ---------- */
function updateIntro(){
  if (autoIntroCheckbox.checked){
    const txt = items.length ? items.map(i => i.name).join(' vs ') : 'Pick or upload sounds';
    introTextArea.value = txt;
  }
  // show on canvas UI overlay
  drawUI();
}

/* populate native voices */
function populateVoices(){
  const voices = speechSynthesis.getVoices();
  voiceSelect.innerHTML = '';
  voices.forEach(v => {
    const opt = document.createElement('option'); opt.value = v.name; opt.textContent = `${v.name} (${v.lang})${v.default? ' • default':''}`; voiceSelect.appendChild(opt);
  });
}
speechSynthesis.onvoiceschanged = populateVoices;
populateVoices();

document.getElementById('previewVoice').addEventListener('click', ()=> {
  const text = introTextArea.value || 'Ready';
  const u = new SpeechSynthesisUtterance(text);
  const vname = voiceSelect.value;
  const voices = speechSynthesis.getVoices();
  const v = voices.find(x=>x.name === vname);
  if (v) u.voice = v;
  speechSynthesis.cancel(); speechSynthesis.speak(u);
});

/* robotic voice (recordable) — simple syllable glottal + pitch mapping */
function roboticSpeak(text, timeOffset = 0){
  // split words and play short tonal syllables using WebAudio
  if (!audioCtx) initAudioContext();
  const words = text.split(/\s+/).slice(0,16);
  let t = audioCtx.currentTime + timeOffset;
  const baseGain = audioCtx.createGain(); baseGain.gain.value = 0.6; baseGain.connect(masterDestination);
  words.forEach((w,idx) => {
    const syll = Math.min(3, Math.ceil(w.length/3));
    const freq = 220 + (idx*60);
    for (let s=0;s<syll;s++){
      const o = audioCtx.createOscillator();
      o.type = 'sawtooth';
      o.frequency.value = freq + Math.random()*40 - 20;
      const g = audioCtx.createGain(); g.gain.value = 0;
      o.connect(g); g.connect(masterDestination);
      // envelope
      g.gain.setValueAtTime(0, t);
      g.gain.linearRampToValueAtTime(0.9, t+0.01);
      g.gain.exponentialRampToValueAtTime(0.001, t+0.12);
      o.start(t); o.stop(t+0.14);
      t += 0.16;
    }
    // small pause between words
    t += 0.06;
  });
}

/* preview robotic */
previewRobotBtn.addEventListener('click', ()=> {
  roboticSpeak(introTextArea.value || 'Ready');
});

/* ---------- Background presets (preview all then choose) ---------- */
const bgPresets = [
  {id:'nebula', name:'Particle Nebula'},
  {id:'wave', name:'Gradient Wave'},
  {id:'galaxy', name:'Galaxy Warp'},
  {id:'grid', name:'Retro Grid'},
  {id:'bubbles', name:'Bubbles'}
];
let selectedBG = 'nebula';
bgPresets.forEach(p=>{
  const b = document.createElement('button'); b.className='btn small'; b.textContent=p.name;
  b.onclick = ()=> { selectedBG = p.id; statusLabel.textContent = 'BG: '+p.name; };
  bgPresetButtons.appendChild(b);
});

/* background rendering modes for canvas full-screen */
function drawFullBGMode(){
  // uses bgParticles earlier; modulate color per selectedBG
  requestAnimationFrame(drawFullBGMode);
  // drawing already done by drawBG() but we can add style modifications per selectedBG
  // (for simplicity we keep same drawBG, but animate particles speed/color based on selectedBG)
}
drawFullBGMode();

/* ---------- Audio graph + recording ---------- */
function initAudioContext(){
  if (audioCtx) return;
  audioCtx = new (window.AudioContext || window.webkitAudioContext)();
  masterDestination = audioCtx.createMediaStreamDestination();
  masterGain = audioCtx.createGain(); masterGain.gain.value = 1;
  masterGain.connect(masterDestination);
}

/* Start recording: capture stack canvas stream and mix audio */
let recordedBlob = null;
startRecordBtn.addEventListener('click', async ()=>{
  if (recorder && recorder.state === 'recording'){ alert('Recording already running'); return; }
  if (!items.length){ alert('Add at least one item to record'); return; }
  initAudioContext();
  // ensure all audio elements are connected to audioCtx so they get captured
  items.forEach(it=>{
    if (!it.sourceNode){
      const src = audioCtx.createMediaElementSource(it.audioEl);
      src.connect(masterGain);
      it.sourceNode = src;
    }
  });

  // if robotic selected ensure it goes to masterGain as well
  roboticVoiceEnabled = useRoboticCheckbox.checked;

  // prepare canvas mixed stream: we capture the canvasStack by compositing canvases into a single offscreen canvas
  const width = funnelCanvas.width / devicePixelRatio;
  const height = funnelCanvas.height / devicePixelRatio;
  const compositeCanvas = document.createElement('canvas');
  compositeCanvas.width = width * devicePixelRatio;
  compositeCanvas.height = height * devicePixelRatio;
  compositeCanvas.style.width = width + 'px';
  compositeCanvas.style.height = height + 'px';
  const compCtx = compositeCanvas.getContext('2d');
  compCtx.scale(devicePixelRatio, devicePixelRatio);

  // draw loop to composite current canvases into compositeCanvas
  let compAnimating = true;
  function compositeLoop(){
    if (!compAnimating) return;
    // clear
    compCtx.clearRect(0,0,width,height);
    // draw background, funnel, UI canvas content onto comp
    compCtx.drawImage(bgCanvas,0,0,width,height);
    compCtx.drawImage(funnelCanvas,0,0,width,height);
    compCtx.drawImage(uiCanvas,0,0,width,height);
    requestAnimationFrame(compositeLoop);
  }
  compositeLoop();

  // capture stream from composite canvas
  const canvasStream = compositeCanvas.captureStream(30); // 30fps
  // combine audio tracks from masterDestination.stream
  const mixedStream = new MediaStream();
  // add canvas tracks
  canvasStream.getVideoTracks().forEach(t => mixedStream.addTrack(t));
  // add audio tracks from audioCtx destination
  masterDestination.stream.getAudioTracks().forEach(t => mixedStream.addTrack(t));

  // create MediaRecorder with chosen format
  recordingFormat = document.getElementById('recordFormat').value || 'video/webm';
  try {
    recorder = new MediaRecorder(mixedStream, { mimeType: recordingFormat });
  } catch (err){
    alert('Recording format not supported by browser; trying fallback WebM.');
    try{ recorder = new MediaRecorder(mixedStream, { mimeType: 'video/webm;codecs=vp9' }); } catch(e){ recorder = new MediaRecorder(mixedStream); }
  }
  recordingChunks = [];
  recorder.ondataavailable = e => { if (e.data && e.data.size) recordingChunks.push(e.data); };
  recorder.onstop = ()=> {
    recordedBlob = new Blob(recordingChunks, { type: recordingFormat });
    statusLabel.textContent = 'Recording ready';
    compAnimating = false;
  };
  recorder.start();
  statusLabel.textContent = 'Recording...';
});

/* stop recording */
stopRecordBtn.addEventListener('click', ()=> {
  if (recorder && recorder.state === 'recording') recorder.stop();
  else alert('Not recording');
});

/* download recorded file */
downloadRecordBtn.addEventListener('click', ()=> {
  if (!recordedBlob){ alert('No recording available'); return; }
  const url = URL.createObjectURL(recordedBlob);
  const a = document.createElement('a'); a.href = url;
  const ext = recordingFormat.includes('mp4') ? 'mp4' : 'webm';
  a.download = `meme-battle.${ext}`; a.click(); URL.revokeObjectURL(url);
});

/* ---------- Battle animation & logic (canvas-driven) ---------- */
let animRunning = false;
let avatars = []; // {item, x,y,vy,landed,coverImage}
let landingOrder = [];

function resetArenaState(){
  avatars.forEach(av => { if (av.img && av.img.src && av.img.src.startsWith('blob:')){ /* keep it */ }});
  avatars = []; landingOrder = []; leaderboard = []; renderLeaderboard(); winnerBox.textContent = 'No winner';
  drawFunnelBase(); clearUI();
  statusLabel.textContent = 'Reset';
}

resetArena.addEventListener('click', ()=> { stopBattle(); resetArenaState(); });

function spawnAvatarsPreview(){
  resetArenaState();
  const rect = stack.getBoundingClientRect();
  const w = rect.width, h = rect.height;
  items.forEach((it, idx)=>{
    const startX = (w*0.2) + Math.random()*(w*0.6);
    const av = {
      item: it,
      x: startX,
      y: -90,
      vy: 0,
      landed:false,
      bounceCount:0,
      img: null
    };
    if (it.coverUrl){
      av.img = new Image(); av.img.src = it.coverUrl;
    }
    avatars.push(av);
  });
  if (!animRunning) { animRunning = true; requestAnimationFrame(animate); }
}

/* start real battle: includes audio playback on landing and recording of arrivals */
function startBattle(){
  if (!items.length) { alert('Add at least 1 item'); return; }
  stopBattle(); resetArenaState();
  // create avatars for each item
  const rect = stack.getBoundingClientRect();
  const w = rect.width, h = rect.height;
  items.forEach((it, idx)=>{
    const startX = (w*0.2) + Math.random()*(w*0.6);
    const av = {
      item: it,
      x: startX,
      y: -90,
      vy: 0,
      landed:false,
      bounceCount:0,
      img: null,
      id: it.id
    };
    if (it.coverUrl){
      av.img = new Image(); av.img.src = it.coverUrl;
    }
    avatars.push(av);
  });
  if (!animRunning) { animRunning = true; requestAnimationFrame(animate); }
  statusLabel.textContent = 'Battle started';
}

/* stop battle elegantly */
function stopBattle(){
  animRunning = false;
  avatars = [];
}

/* animation loop for avatars physics & drawing */
function animate(){
  const rect = stack.getBoundingClientRect();
  const w = rect.width, h = rect.height;
  // redraw funnel/base
  drawFunnelBase();
  // physics step
  const bottomLimit = h - 100;
  fctx.clearRect(0,0,h,0); // no-op just ensure fctx referenced
  // draw funnel again (we did in drawFunnelBase), now overlay avatars
  const drawYoff = 0;
  // clear funnel canvas then draw base + avatars
  fctx.clearRect(0,0,w,h);
  drawFunnelBase();
  avatars.forEach((av,idx)=>{
    // simple gravity + bounce
    av.vy += 0.35 + idx*0.002;
    av.y += av.vy;
    // sway
    av.x += Math.sin((Date.now()/400) + idx)*0.4;
    // collision with bottom
    if (!av.landed && av.y >= bottomLimit){
      av.vy = -av.vy * (0.45 + Math.random()*0.15);
      av.y = bottomLimit;
      av.bounceCount++;
      if (av.bounceCount > 1){
        av.landed = true;
        // trigger landing effects
        onAvatarLand(av);
      }
    }
    // draw avatar circle
    const ax = av.x, ay = av.y, rad = 38;
    fctx.save();
    // avatar background
    fctx.beginPath();
    fctx.arc(ax+rad, ay+rad, rad, 0, Math.PI*2);
    fctx.fillStyle = 'rgba(0,0,0,0.15)'; fctx.fill();
    fctx.closePath();
    // draw image if present
    if (av.img && av.img.complete){
      fctx.save();
      fctx.beginPath();
      fctx.arc(ax+rad, ay+rad, rad, 0, Math.PI*2);
      fctx.clip();
      fctx.drawImage(av.img, ax, ay, rad*2, rad*2);
      fctx.restore();
    } else {
      // draw initials
      fctx.fillStyle = '#12202f';
      fctx.fillRect(ax,ay,rad*2,rad*2);
      fctx.fillStyle = '#fff'; fctx.font = 'bold 14px sans-serif';
      const initials = av.item.name.slice(0,2).toUpperCase();
      fctx.fillText(initials, ax+rad-10, ay+rad+6);
    }
    // label bubble
    fctx.fillStyle = 'rgba(0,0,0,0.6)';
    const label = av.item.name;
    fctx.font = '12px sans-serif';
    const labelW = fctx.measureText(label).width + 16;
    const lx = ax + rad - labelW/2 + rad;
    fctx.fillRect(lx, ay + rad*2 + 6, labelW, 22);
    fctx.fillStyle = '#fff';
    fctx.fillText(label, lx + 8, ay + rad*2 + 20);
    fctx.restore();
  });
  // UI canvas overlay (intro text / little HUD)
  drawUI();
  if (animRunning) requestAnimationFrame(animate);
  else { /* clean up if stopped */ }
}

/* on landing: play audio + record leaderboard */
function onAvatarLand(av){
  // ensure audio elements are connected to audioCtx for recording
  if (!audioCtx) initAudioContext();
  try{
    if (!av.item.sourceNode){
      const src = audioCtx.createMediaElementSource(av.item.audioEl);
      src.connect(masterGain);
      av.item.sourceNode = src;
    }
    av.item.audioEl.currentTime = 0;
    av.item.audioEl.play().catch(()=>{ /* autoplay may be blocked until user interacts */ });
  } catch(e){ console.warn('play fail', e); }
  // add to landing order if not already
  if (!landingOrder.find(l=>l.id === av.id)){
    landingOrder.push({id:av.id, name:av.item.name, cover:av.item.coverUrl});
    renderLeaderboard();
    // if first landed, update winner after small delay
    if (landingOrder.length === 1){
      setTimeout(()=> {
        const w = landingOrder[0];
        if (!w) return;
        winnerBox.innerHTML = '';
        const cont = document.createElement('div'); cont.style.display='flex'; cont.style.flexDirection='column'; cont.style.alignItems='center';
        const cov = document.createElement('div'); cov.style.width='120px'; cov.style.height='120px'; cov.style.borderRadius='12px'; cov.style.overflow='hidden';
        if (w.cover){
          const im = document.createElement('img'); im.src = w.cover; im.style.width='100%'; im.style.height='100%'; im.style.objectFit='cover';
          cov.appendChild(im);
        } else {
          cov.style.display='flex'; cov.style.alignItems='center'; cov.style.justifyContent='center'; cov.style.background='linear-gradient(90deg,#6f8cff,#7ce3c9)';
          cov.textContent = w.name.slice(0,2).toUpperCase();
        }
        const nm = document.createElement('div'); nm.textContent = w.name; nm.style.marginTop='8px'; nm.style.fontWeight='800';
        cont.appendChild(cov); cont.appendChild(nm); winnerBox.appendChild(cont);
        // announce via TTS or robotic
        if (useRoboticCheckbox.checked) roboticSpeak(`${w.name} is the winner`);
        else {
          // native TTS (preview only; may not be captured in recording)
          const u = new SpeechSynthesisUtterance(w.name + ' is the winner');
          speechSynthesis.cancel(); speechSynthesis.speak(u);
        }
      }, 400);
    }
  }
}

/* render leaderboard */
function renderLeaderboard(){
  leaderboardEl.innerHTML = '';
  landingOrder.forEach((l, i)=>{
    const row = document.createElement('div'); row.className='leaderRow';
    const pos = document.createElement('div'); pos.className='pos'; pos.textContent = (i+1);
    const cov = document.createElement('div'); cov.className='lbCover';
    if (l.cover){ const im = document.createElement('img'); im.src = l.cover; im.style.width='100%'; im.style.height='100%'; im.style.objectFit='cover'; cov.appendChild(im); }
    else cov.textContent = l.name.slice(0,2).toUpperCase();
    const nm = document.createElement('div'); nm.textContent = l.name; nm.style.fontWeight='700';
    row.appendChild(pos); row.appendChild(cov); row.appendChild(nm);
    leaderboardEl.appendChild(row);
  });
}

/* copy board */
copyBoard.addEventListener('click', ()=> {
  if (!landingOrder.length) { alert('No entries'); return; }
  const txt = landingOrder.map((l,i)=> `${i+1}. ${l.name}`).join('\n');
  navigator.clipboard?.writeText(txt).then(()=> alert('Copied'), ()=> alert('Copy failed'));
});

/* announce winner button */
announceWinner.addEventListener('click', ()=> {
  if (!landingOrder.length) { alert('No winner'); return; }
  const w = landingOrder[0];
  if (useRoboticCheckbox.checked) roboticSpeak(`${w.name} is the winner`);
  else { const u = new SpeechSynthesisUtterance(`${w.name} is the winner`); speechSynthesis.cancel(); speechSynthesis.speak(u); }
});

/* preview drop */
previewDrop.addEventListener('click', ()=> {
  spawnAvatarsPreview();
  // optional: play intro preview
  if (useRoboticCheckbox.checked) roboticSpeak(introTextArea.value || 'Ready');
  else { const u = new SpeechSynthesisUtterance(introTextArea.value || 'Ready'); speechSynthesis.cancel(); speechSynthesis.speak(u); }
});

/* start battle */
startBtn.addEventListener('click', ()=> {
  // speak intro
  if (autoIntroCheckbox.checked) introTextArea.value = items.map(i=>i.name).join(' vs ');
  if (useRoboticCheckbox.checked) {
    // speak robotic then spawn after short delay to allow robot speech to play
    roboticSpeak(introTextArea.value || 'Ready', 0);
    setTimeout(()=> { startBattle(); }, 900 + items.length * 80);
  } else {
    // use native TTS for preview (may not be recorded)
    const u = new SpeechSynthesisUtterance(introTextArea.value || 'Ready');
    speechSynthesis.cancel();
    u.onend = ()=> { startBattle(); };
    speechSynthesis.speak(u);
  }
});

/* ---------- UI overlay drawing ---------- */
function drawUI(){
  const rect = stack.getBoundingClientRect();
  const w = rect.width, h = rect.height;
  uctx.clearRect(0,0,w,h);
  // draw intro/title
  uctx.fillStyle = 'rgba(0,0,0,0.3)';
  uctx.font = 'bold 22px sans-serif';
  uctx.textAlign = 'center';
  uctx.fillStyle = '#fff';
  uctx.fillText(introTextArea.value || (items.map(i=>i.name).join(' vs ')), w/2, 36);
  // small HUD at bottom
  uctx.font = '13px sans-serif';
  uctx.fillStyle = 'rgba(255,255,255,0.85)';
  uctx.textAlign = 'left';
  uctx.fillText(`Items: ${items.length}  Landed: ${landingOrder.length}`, 12, h - 12);
}

/* initial draw */
drawFunnelBase(); drawUI();

/* ---------- Wire up recording-related: ensure audio nodes when user interacts ---------- */
document.addEventListener('pointerdown', ()=> { try{ speechSynthesis.getVoices(); }catch(e){}; if (!audioCtx) initAudioContext(); }, {once:true});

/* ---------- Initial UI population ---------- */
renderItems();
populateVoices();

/* Auto-resize canvas stack */
fitCanvases();
window.addEventListener('load', ()=> { fitCanvases(); drawFunnelBase(); drawUI(); });

</script>
</body>
                                                                 </html>
